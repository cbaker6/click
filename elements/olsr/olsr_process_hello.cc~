//TED 150404: created

#include <click/config.h>
#include <click/confparse.hh>
#include <click/error.hh>
#include <click/ipaddress.hh>
#include <click/packet_anno.hh>
#include "click_olsr.hh"
#include "olsr_neighbor_infobase.hh"
#include "olsr_process_hello.hh"
#include "olsr_packethandle.hh"
#include "clicknet/ether.h"

CLICK_DECLS

OLSRProcessHello::OLSRProcessHello()
{
}

OLSRProcessHello::~OLSRProcessHello()
{
}


int
OLSRProcessHello::configure(Vector<String> &conf, ErrorHandler *errh)
{
	int neighbor_hold_time;
	int hello_period;
	//int lq_window_size;
/*
	if (cp_va_parse(conf, this, errh,
	                cpInteger,"Neihbor Hold time",&neighbor_hold_time,
	                cpElement, "LinkInfoBase Element", &_linkInfo,
	                cpElement, "NeighborInfoBase Element", &_neighborInfo,
	                cpElement, "InterfaceInfoBase Element", &_interfaceInfo,
	                cpElement, "Routing Table Element", &_routingTable,
	                cpElement, "TC generator element", &_tcGenerator,
	                cpElement, "localIfInfoBase Element", &_localIfInfoBase,
	                cpIPAddress, "Main IPAddress of node", &_myMainIp,  0) < 0)*/
 	if (cp_va_kparse(conf, this, errh,
	                "NEIGHBOR_HOLD_TIME", cpkP+cpkM, cpInteger, &neighbor_hold_time,
	                "LINKINFOBASE_ELEMENT", cpkP+cpkM, cpElement, &_linkInfo,
	                "NEIGHBORINFOBASE_ELEMENT", cpkP+cpkM, cpElement, &_neighborInfo,
	                "INTERFACEINFOBASE_ELEMENT", cpkP+cpkM, cpElement, &_interfaceInfo,
	                "ROUTING_TABLE_ELEMENT", cpkP+cpkM, cpElement, &_routingTable,
	                "TC_GENERATOR_ELEMENT", cpkP+cpkM, cpElement, &_tcGenerator,
	                "LOCALIFINFOBASE_ELEMENT", cpkP+cpkM, cpElement, &_localIfInfoBase,
	                "MAIN_IPADDRESS_OF_NODE", cpkP+cpkM, cpIPAddress, &_myMainIp,
			"HELLO_PERIOD", cpkP+cpkN, cpInteger, &hello_period,
			"LQ_WINDOW", cpkP+cpkN, cpInteger, &_lq_window_size,  cpEnd) < 0)
		return -1;
	_neighbor_hold_time_tv=make_timeval ((int) (neighbor_hold_time / 1000),(neighbor_hold_time % 1000));
	//Added by Corey
	_lq_window_time_tv=make_timeval ((int) (hello_period*_lq_window_size / 1000),(hello_period*_lq_window_size % 1000));
	return 0;
}

void
OLSRProcessHello::push(int, Packet *packet)
{

	msg_hdr_info msg_info;
	hello_hdr_info hello_info;
	link_hdr_info link_info;
	link_data *link_tuple;
	neighbor_data *neighbor_tuple;

	bool update_twohop = false;
	bool twohop_deleted = false;
	bool new_twohop_added = false;
	bool new_neighbor_added = false;
	bool mpr_selector_added = false;
	struct timeval now;
	IPAddress neighbor_main_address, originator_address, source_address;
	click_gettimeofday(&now);
	msg_info = OLSRPacketHandle::get_msg_hdr_info(packet, 0);

	//click_chatter ("Process HELLO: validity time %d %d",  msg_info.validity_time.tv_sec,msg_info.validity_time.tv_usec);
	originator_address = msg_info.originator_address;
	//dst_ip_anno must be set, must be source address of ippacket
	source_address = packet->dst_ip_anno();

	int paint=static_cast<int>(PAINT_ANNO(packet));//packets get marked with paint 0..N depending on Interface they arrive on
	IPAddress receiving_If_IP=_localIfInfoBase->get_iface_addr(paint); //gets IP of Interface N
	//7.1.1 - 1
	link_tuple = _linkInfo->find_link(receiving_If_IP, source_address);

	if (link_tuple == NULL)
	{  
		#ifndef ENABLE_ETX
		link_tuple = _linkInfo->add_link(receiving_If_IP, source_address, (now + msg_info.validity_time));
		
		#else
		
		link_tuple = _linkInfo->add_link(receiving_If_IP, source_address, (now + msg_info.validity_time), (now + _lq_window_time_tv));
		#endif

		link_tuple->L_SYM_time = now - make_timeval(1,0);
		link_tuple->L_ASYM_time = now + msg_info.validity_time;
		link_tuple->_main_addr = originator_address;
		click_chatter("%s adding link to %s\n", receiving_If_IP.unparse().c_str(), source_address.unparse().c_str());
	}
	else
	{
		link_tuple->L_ASYM_time = now + msg_info.validity_time;
		if ( _interfaceInfo->get_main_address(link_tuple->L_neigh_iface_addr) == originator_address)
		{ // From RFC 8.2.1
			if (link_tuple->L_SYM_time >= now)
				update_twohop = true;
		}

		#ifdef ENABLE_ETX

		//COREY - Update link metrics
		if ((now.tv_sec <= link_tuple->L_time_metric_exp.tv_sec) && (now.tv_usec <= link_tuple->L_time_metric_exp.tv_usec)){

			if (link_tuple->L_num_of_pkts_rec < _lq_window_size)
				link_tuple->L_num_of_pkts_rec += 1;	
		}else{
			link_tuple->L_time_metric_exp = now + _lq_window_time_tv; 
			if (link_tuple->L_num_of_pkts_rec > 0)
				link_tuple->L_num_of_pkts_rec -= 1;

			if (!link_tuple->L_rec_enough_pkts_to_use_metric)
				link_tuple->L_rec_enough_pkts_to_use_metric = true;

		//click_chatter("*****COREY Number of Packers Received %d\n",link_tuple->L_num_of_pkts_rec);
		}

		#endif 
	}
	hello_info = OLSRPacketHandle::get_hello_hdr_info(packet, sizeof(olsr_msg_hdr));
	//from RFC 8.1
	neighbor_main_address = originator_address;
	neighbor_tuple = _neighborInfo->find_neighbor(neighbor_main_address);
	if (neighbor_tuple == NULL)
	{
		neighbor_tuple = _neighborInfo->add_neighbor(neighbor_main_address);
		neighbor_tuple->N_status = OLSR_NOT_NEIGH;
	}
	neighbor_tuple->N_willingness = hello_info.willingness;

	#ifdef ENABLE_ETX
	neighbor_tuple->link_quality = calculate_average_lq(*link_tuple);
	//click_chatter("*****COREY LQ: %d",neighbor_tuple->link_quality);
	#endif

	//end 8.1
	// end 7.1.1
	int link_msg_bytes_left = msg_info.msg_size - sizeof(olsr_msg_hdr) - sizeof(olsr_hello_hdr);
	int link_msg_offset = sizeof(olsr_msg_hdr) + sizeof(olsr_hello_hdr);
	#ifndef ENABLE_ETX
	int olsr_link_hdr_size = sizeof(olsr_link_hdr);
	#else
	int olsr_link_hdr_size = sizeof(olsr_lq_link_hdr);
	#endif

	int address_offset = link_msg_offset + olsr_link_hdr_size;

	if (link_msg_bytes_left > 0)
	{ //there are advertised links in the hello-message
		#ifndef ENABLE_ETX		
		int size_of_address_field = sizeof(in_addr);
		#else
		int size_of_address_field = sizeof(in_address_w_metrics);
		#endif

		do
		{
			link_info = OLSRPacketHandle::get_link_hdr_info(packet, link_msg_offset);
/*
			#ifdef ENABLE_ETX
			
			//Save link_quality of interface with the best link_quality
			if ((neighbor_tuple->N_link_quality == 0) || (neighbor_tuple->N_link_quality < link_info.link_quality)){ 	
				neighbor_tuple->N_link_quality = link_info.link_quality; 
				//_neighborInfo->print_neighbor_set();
			}
			
			//neighbor_tuple->N_link_quality = link_info.link_quality;
			#endif
*/
			int interface_address_bytes_left = link_info.link_msg_size - olsr_link_hdr_size;
			do
			{
				#ifndef ENABLE_ETX
				in_addr *address = (in_addr *) (packet->data() + address_offset);
				IPAddress neighbor_address = IPAddress(*address);
				#else
				in_address_w_metrics *address = (in_address_w_metrics *) (packet->data() + address_offset);
				in_address_w_metrics addr_w_metrics = *address;				
				IPAddress neighbor_address = IPAddress(addr_w_metrics.address);
				uint8_t neighbor_link_quality = addr_w_metrics.link_quality;

				#endif				
				
				//from RFC 7.1.1 - 2
				if (neighbor_address == receiving_If_IP)
				{
					if (link_info.link_type == OLSR_LOST_LINK)
					{
						link_tuple->L_SYM_time = now - make_timeval(1,0);  // == expired
						link_tuple->L_num_of_pkts_rec = 0; //If link lost, packets received should become 0
					}
					else if (link_info.link_type == OLSR_SYM_LINK || link_info.link_type == OLSR_ASYM_LINK)
					{
						link_tuple->L_SYM_time = now + msg_info.validity_time;
						link_tuple->L_time = link_tuple->L_SYM_time + _neighbor_hold_time_tv;
					}

					if (link_tuple->L_time < link_tuple->L_ASYM_time)
					{
						link_tuple->L_time = link_tuple->L_ASYM_time;
					}

					//from RFC 8.1
					if ( link_tuple->L_SYM_time >= now )
					{
						if (neighbor_tuple->N_status != OLSR_SYM_NEIGH)
						{ //RFC 8.5
							new_neighbor_added = true;
						}
						neighbor_tuple->N_status = OLSR_SYM_NEIGH;
						neighbor_tuple->N_link_quality = neighbor_link_quality;
					}
					else
					{
						neighbor_tuple->N_status = OLSR_NOT_NEIGH;
						neighbor_tuple->N_link_quality = 0;
					}
					_neighborInfo->print_neighbor_set(); //Added by Corey
					// end 7.1.1 - 2
				}

				//from RFC 8.2.1
				if(update_twohop && (link_info.neigh_type==OLSR_SYM_NEIGH||link_info.neigh_type==OLSR_MPR_NEIGH))
				{
					if ( neighbor_address != _myMainIp )
					{
						IPAddress main_neighbor_address = _interfaceInfo->get_main_address(neighbor_address);
						if (_neighborInfo->find_twohop_neighbor(originator_address, main_neighbor_address) == 0)
							new_twohop_added = true;
						_neighborInfo->add_twohop_neighbor(originator_address, main_neighbor_address, (now+msg_info.validity_time));
					}
				}
				else if (update_twohop && link_info.neigh_type == OLSR_NOT_NEIGH)
				{
					IPAddress main_neighbor_address = _interfaceInfo->get_main_address(neighbor_address);
					_neighborInfo->remove_twohop_neighbor(originator_address, main_neighbor_address);
					twohop_deleted = true; //RFC 8.5
				}	// end 8.2.1

				// from RFC 8.4.1
				//click_chatter ("main address of neighbor: %s, my Main IP %s\n",_interfaceInfo->get_main_address(neighbor_address).unparse().c_str(),_myMainIp.unparse().c_str());
				if ( _interfaceInfo->get_main_address(neighbor_address) == _myMainIp )
				{
					if (link_info.neigh_type == OLSR_MPR_NEIGH )
					{
						mpr_selector_data *mpr_selector = _neighborInfo->find_mpr_selector(originator_address);
						if (mpr_selector == 0)
						{
							mpr_selector = _neighborInfo->add_mpr_selector(originator_address, (now + msg_info.validity_time));
							mpr_selector_added = true;
						}
						else
						{
							mpr_selector->MS_time = now + msg_info.validity_time;
						}
					}
				}//end 8.4.1
			
				interface_address_bytes_left -= size_of_address_field;
				address_offset += size_of_address_field;
			}
			while ( interface_address_bytes_left >= (int) size_of_address_field );

			link_msg_bytes_left -= link_info.link_msg_size;
			link_msg_offset += link_info.link_msg_size;
			address_offset += olsr_link_hdr_size;
		}
		while (  link_msg_bytes_left >= (int) (olsr_link_hdr_size + size_of_address_field)  );
	}

	//_neighborInfo->print_mpr_selector_set();
	if ( mpr_selector_added )
		_tcGenerator->notify_mpr_selector_changed();  //this includes incrementing ansn; if activated an additional tc message is sent;
	// in a strictly RFC interpretation this should only be done if change is based on link failure
	if (twohop_deleted || new_twohop_added || new_neighbor_added)
	{
		_neighborInfo->compute_mprset();
		_routingTable->compute_routing_table();
	}
	output(0).push(packet);
}

/// == Added by Corey for Metric calculation ====================================================================================================
int
OLSRProcessHello:: calculate_average_lq(link_data local_link)
{
	if (local_link.L_rec_enough_pkts_to_use_metric){
		int lq_quotient = (local_link.L_num_of_pkts_rec / _lq_window_size) * 100;
		int lq_remainder = (local_link.L_num_of_pkts_rec % _lq_window_size) * 10;
		int lq = lq_quotient + lq_remainder;
		
		//click_chatter("*****COREY Pkts Rcvd: %d LQCalc: %d\n",local_link.L_num_of_pkts_rec, lq);
		return lq;
	}else{
		return 0;
	}
}
/*int
OLSRProcessHello:: update_link_metrics(link_data local_link)
{
	if local_links->
}


int
OLSRProcessHello:: calculate_etx(link_data local_link)
{
	if local_links->
}*/
// ====================================================================================================


/// == mvhaen ====================================================================================================
void
OLSRProcessHello::set_neighbor_hold_time_tv(int neighbor_hold_time)
{
	_neighbor_hold_time_tv=make_timeval ((int) (neighbor_hold_time / 1000),(neighbor_hold_time % 1000));;
	click_chatter ("_neighbor_hold_time_tv = %d %d\n", _neighbor_hold_time_tv.tv_sec,  _neighbor_hold_time_tv.tv_usec);
}

int
OLSRProcessHello::set_neighbor_hold_time_tv_handler(const String &conf, Element *e, void *, ErrorHandler * errh)
{
	OLSRProcessHello* me = (OLSRProcessHello *) e;
	int new_nbr_hold_time;
	int res = cp_va_parse( conf, me, errh, cpInteger, "Neighbor Hold time", &new_nbr_hold_time, 0 );	
	if ( res < 0 )
		return res;
	me->set_neighbor_hold_time_tv(new_nbr_hold_time);
	return res;
}

void
OLSRProcessHello::add_handlers()
{
	add_write_handler("set_neighbor_hold_time_tv", set_neighbor_hold_time_tv_handler, (void *)0);
}
/// == !mvhaen ===================================================================================================

CLICK_ENDDECLS
EXPORT_ELEMENT(OLSRProcessHello)

